import { useEffect, useCallback, useRef } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { AppState, Platform } from 'react-native';

import { selectUser } from '@entities/auth';
import PushNotificationService from "@shared/services/PushNotificationService";
import {
    fetchNotifications,
    fetchUnreadCount,
    fetchStopNotifications,
    fetchOrderNotifications,
    performBulkOperation,
    addNotification,
    updateNotificationData
} from "@entities/notification";
import { fetchAllStops, selectStops } from "@entities/stop";

export const useNotifications = (navigation) => {
    const dispatch = useDispatch();
    const user = useSelector(selectUser);
    const stops = useSelector(selectStops);
    const appState = useRef(AppState.currentState);

    const initializationAttempted = useRef(false);
    const refreshing = useRef(false);
    const setupDone = useRef(false);
    const navigationHandlersSet = useRef(false);
    const lastRefreshTime = useRef(0);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –¥–ª—è —Ä–æ–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const isNotificationsAvailable = user?.role === 'CLIENT';

    useEffect(() => {
        const initializePush = async () => {
            // –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è push-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤ AppContainer
            // –ó–¥–µ—Å—å —Ç–æ–ª—å–∫–æ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ö—ç–Ω–¥–ª–µ—Ä—ã –¥–ª—è –∫–ª–∏–µ–Ω—Ç–æ–≤
            if (isNotificationsAvailable && navigation) {
                setupNavigationHandlers();
            }
        };

        const timeoutId = setTimeout(() => {
            initializePush();
        }, 100);

        return () => {
            clearTimeout(timeoutId);
        };
    }, [user?.id, user?.role, navigation, setupNavigationHandlers, isNotificationsAvailable]);

    useEffect(() => {
        if (setupDone.current) return;
        setupDone.current = true;

        const handleAppStateChange = (nextAppState) => {
            const now = Date.now();

            if (
                appState.current.match(/inactive|background/) &&
                nextAppState === 'active' &&
                isNotificationsAvailable &&
                !refreshing.current &&
                (now - lastRefreshTime.current > 30000)
            ) {
                console.log('üîÑ App became active, refreshing notifications');
                refreshing.current = true;
                lastRefreshTime.current = now;

                dispatch(fetchUnreadCount());
                setTimeout(() => { refreshing.current = false; }, 1000);
            }
            appState.current = nextAppState;
        };

        const subscription = AppState.addEventListener('change', handleAppStateChange);
        return () => {
            subscription?.remove();
            setupDone.current = false;
        };
    }, []);

    const refreshNotifications = useCallback(() => {
        const now = Date.now();

        if (refreshing.current || (now - lastRefreshTime.current < 5000)) {
            console.log('üö´ Refresh skipped - too frequent or already refreshing');
            return;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –¥–ª—è —Ä–æ–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        if (!user || user?.role !== 'CLIENT') {
            console.log('üö´ Notifications not available for role:', user?.role);
            return;
        }

        refreshing.current = true;
        lastRefreshTime.current = now;

        console.log('üîÑ Manual refresh notifications');
        dispatch(fetchUnreadCount());
        dispatch(fetchNotifications({
            page: 1,
            refresh: true,
            includeData: true // –í–ê–ñ–ù–û: –í–∫–ª—é—á–∞–µ–º —Å–≤—è–∑–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        }));

        setTimeout(() => { refreshing.current = false; }, 1000);
    }, [dispatch, user?.id, user?.role]);

    const setupNavigationHandlers = useCallback(() => {
        if (navigationHandlersSet.current || !navigation || !isNotificationsAvailable) {
            return;
        }

        console.log('üß≠ Setting up navigation handlers');
        navigationHandlersSet.current = true;

        // –£–ë–ò–†–ê–ï–ú: –î—É–±–ª–∏—Ä—É—é—â–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π - —É–∂–µ –µ—Å—Ç—å –≤ AppNavigator
        // PushNotificationService.navigateToStops = async (data) => {
        //     console.log('üß≠ navigateToStops called with:', data);
        //     // ... –æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥
        // };

        // PushNotificationService.navigateToOrder = (data) => {
        //     console.log('üß≠ navigateToOrder called with:', data);
        //     // ... –æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥
        // };

        // –í–∞–∂–Ω–æ: —Å–æ–æ–±—â–∞–µ–º —Å–µ—Ä–≤–∏—Å—É, —á—Ç–æ –Ω–∞–≤–∏–≥–∞—Ü–∏—è –≥–æ—Ç–æ–≤–∞
        setTimeout(() => {
            PushNotificationService.setNavigationReady();
            console.log('üß≠ Navigation handlers setup complete and marked as ready');
        }, 100);

    }, [navigation, dispatch, stops, isNotificationsAvailable]);

    // –ò–°–ü–†–ê–í–õ–ï–ù–û: –£–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏—Ä—É—é—â—É—é —Ñ—É–Ω–∫—Ü–∏—é initializePushNotifications
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è push-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤ AppContainer
    // const initializePushNotifications = useCallback(async () => {
    //     if (initializationAttempted.current) {
    //         return true;
    //     }
    //     // ... –æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥
    // }, [user?.id, setupNavigationHandlers]);

    // –û–ë–ù–û–í–õ–ï–ù–ù–´–ï —Ñ—É–Ω–∫—Ü–∏–∏ —Å–æ–∑–¥–∞–Ω–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π —Å –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
    const showStopNotification = useCallback((stopData) => {
        if (isNotificationsAvailable) {
            const stopId = typeof stopData.id === 'string' ? parseInt(stopData.id) : stopData.id;

            console.log('üöõ Creating stop notification for stopId:', stopId);

            PushNotificationService.showStopNotification({
                ...stopData,
                id: stopId
            })
                .then(() => {
                    console.log('‚úÖ Stop notification sent successfully');
                })
                .catch((error) => {
                    console.error('‚ùå Error sending stop notification:', error);
                });

            // –ò–°–ü–†–ê–í–õ–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª–Ω—ã–µ –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
            dispatch(addNotification({
                id: Date.now(),
                title: `üöõ –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤ —Ä–∞–π–æ–Ω–µ ${stopData.district?.name}`,
                content: `–ù–æ–≤–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–æ –∞–¥—Ä–µ—Å—É: ${stopData.address}`,
                type: 'SYSTEM',
                isRead: false,
                createdAt: new Date().toISOString(),
                // –í–ê–ñ–ù–û: –î–æ–±–∞–≤–ª—è–µ–º stopId –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
                stopId: stopId,
                // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
                data: {
                    type: 'STOP_NOTIFICATION',
                    stopId: stopId,
                    districtId: stopData.districtId,
                    url: `iceberg://stop/${stopId}`,
                    address: stopData.address,
                    startTime: stopData.startTime?.toISOString(),
                    endTime: stopData.endTime?.toISOString()
                }
            }));

            dispatch(fetchUnreadCount());
        }
    }, [dispatch, isNotificationsAvailable]);

    const showStopUpdateNotification = useCallback((stopData, changes) => {
        const userDistrictId = user?.client?.districtId || user?.districtId;

        if (isNotificationsAvailable && userDistrictId === stopData.districtId) {
            PushNotificationService.showStopUpdateNotification(stopData, changes);

            // –ò–°–ü–†–ê–í–õ–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª–Ω—ã–µ –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
            dispatch(addNotification({
                id: Date.now(),
                title: `üìù –ò–∑–º–µ–Ω–µ–Ω–∏—è –≤ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ (${stopData.district?.name})`,
                content: `–û—Å—Ç–∞–Ω–æ–≤–∫–∞: ${stopData.address}\n${changes.join('\n')}`,
                type: 'SYSTEM',
                isRead: false,
                createdAt: new Date().toISOString(),
                // –í–ê–ñ–ù–û: –î–æ–±–∞–≤–ª—è–µ–º stopId –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
                stopId: stopData.id,
                // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
                data: {
                    type: 'STOP_UPDATE',
                    stopId: stopData.id,
                    districtId: stopData.districtId,
                    url: `iceberg://stop/${stopData.id}`,
                    changes: changes,
                    address: stopData.address
                }
            }));

            dispatch(fetchUnreadCount());
        }
    }, [dispatch, user]);

    const showStopCancelNotification = useCallback((stopData) => {
        const userDistrictId = user?.client?.districtId || user?.districtId;

        if (isNotificationsAvailable && userDistrictId === stopData.districtId) {
            PushNotificationService.showStopCancelNotification(stopData);

            // –ò–°–ü–†–ê–í–õ–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª–Ω—ã–µ –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
            dispatch(addNotification({
                id: Date.now(),
                title: `‚ùå –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞ (${stopData.district?.name})`,
                content: `–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–æ –∞–¥—Ä–µ—Å—É ${stopData.address} –±—ã–ª–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞`,
                type: 'SYSTEM',
                isRead: false,
                createdAt: new Date().toISOString(),
                // –í–ê–ñ–ù–û: –î–æ–±–∞–≤–ª—è–µ–º stopId –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
                stopId: stopData.id,
                // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
                data: {
                    type: 'STOP_CANCEL',
                    stopId: stopData.id,
                    districtId: stopData.districtId,
                    url: `iceberg://stop/${stopData.id}`,
                    address: stopData.address,
                    cancelled: true,
                    cancelledAt: new Date().toISOString()
                }
            }));

            dispatch(fetchUnreadCount());
        }
    }, [dispatch, user]);

    const showProductNotification = useCallback((productData) => {
        if (isNotificationsAvailable) {
            PushNotificationService.showLocalNotification({
                title: `üÜï –ù–æ–≤—ã–π —Ç–æ–≤–∞—Ä: ${productData.name}`,
                body: `–¶–µ–Ω–∞: ${productData.price} ‚ÇΩ`,
                channelId: 'default',
                data: {
                    type: 'PRODUCT_NOTIFICATION',
                    productId: productData.id,
                    url: `iceberg://product/${productData.id}`
                }
            });

            // –û–ë–ù–û–í–õ–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø—Ä–æ–¥—É–∫—Ç–∞
            dispatch(addNotification({
                id: Date.now(),
                title: `üÜï –ù–æ–≤—ã–π —Ç–æ–≤–∞—Ä: ${productData.name}`,
                content: `–¶–µ–Ω–∞: ${productData.price} ‚ÇΩ${productData.description ? '\n' + productData.description : ''}`,
                type: 'PROMOTION',
                isRead: false,
                createdAt: new Date().toISOString(),
                // –ù–û–í–û–ï: –î–æ–±–∞–≤–ª—è–µ–º productId
                productId: productData.id,
                // –ù–û–í–û–ï: –î–æ–±–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø—Ä–æ–¥—É–∫—Ç–∞
                data: {
                    type: 'PRODUCT_NOTIFICATION',
                    productId: productData.id,
                    url: `iceberg://product/${productData.id}`,
                    name: productData.name,
                    price: productData.price,
                    images: productData.images
                }
            }));

            dispatch(fetchUnreadCount());
        }
    }, [dispatch, user?.role]);

    // –ù–û–í–´–ï —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–º–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è–º–∏

    /**
     * –ü–æ–ª—É—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± –æ—Å—Ç–∞–Ω–æ–≤–∫–µ
     */
    const getStopNotifications = useCallback(async (stopId) => {
        try {
            const result = await dispatch(fetchStopNotifications(stopId)).unwrap();
            console.log('‚úÖ Stop notifications loaded:', result);
            return result;
        } catch (error) {
            console.error('‚ùå Error loading stop notifications:', error);
            throw error;
        }
    }, [dispatch]);

    /**
     * –ü–æ–ª—É—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –∑–∞–∫–∞–∑–µ
     */
    const getOrderNotifications = useCallback(async (orderId) => {
        try {
            const result = await dispatch(fetchOrderNotifications(orderId)).unwrap();
            console.log('‚úÖ Order notifications loaded:', result);
            return result;
        } catch (error) {
            console.error('‚ùå Error loading order notifications:', error);
            throw error;
        }
    }, [dispatch]);

    /**
     * –ú–∞—Å—Å–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è–º–∏
     */
    const performBulkNotificationOperation = useCallback(async (notificationIds, action) => {
        try {
            console.log('üîÑ Performing bulk operation:', { notificationIds, action });
            const result = await dispatch(performBulkOperation({ notificationIds, action })).unwrap();
            console.log('‚úÖ Bulk operation completed:', result);
            return result;
        } catch (error) {
            console.error('‚ùå Error in bulk operation:', error);
            throw error;
        }
    }, [dispatch]);

    /**
     * –û–±–Ω–æ–≤–∏—Ç—å –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
     */
    const updateNotificationNavigationData = useCallback((notificationId, data) => {
        dispatch(updateNotificationData({ notificationId, data }));
    }, [dispatch]);

    const updateBadgeCount = useCallback((count) => {
        PushNotificationService.setBadgeCount(count);
    }, []);

    const clearBadge = useCallback(() => {
        PushNotificationService.setBadgeCount(0);
    }, []);

    const clearAllNotifications = useCallback(() => {
        PushNotificationService.clearAllNotifications();
        clearBadge();
    }, [clearBadge]);

    const checkTokenStatus = useCallback(async () => {
        const serviceStatus = PushNotificationService.getStatus();
        const deviceToken = await PushNotificationService.getDeviceToken();

        return {
            service: serviceStatus,
            hasDeviceToken: !!deviceToken,
            deviceToken,
            isInitialized: serviceStatus.isInitialized,
            userRole: user?.role,
            navigationReady: serviceStatus.navigationReady,
            pendingNavigationsCount: serviceStatus.pendingNavigationsCount
        };
    }, [user?.role]);

    const forceTokenRefresh = useCallback(async () => {
        if (user?.role === 'CLIENT') {
            try {
                await PushNotificationService.refreshTokenOnServer();
                return true;
            } catch (error) {
                console.error('Token refresh failed:', error);
                return false;
            }
        }
        return false;
    }, [user?.role]);

    return {
        // –°—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –º–µ—Ç–æ–¥—ã
        initializePushNotifications,
        refreshNotifications,
        showStopNotification,
        showStopUpdateNotification,
        showStopCancelNotification,
        showProductNotification,
        updateBadgeCount,
        clearBadge,
        clearAllNotifications,
        checkTokenStatus,
        forceTokenRefresh,

        // –ù–û–í–´–ï –º–µ—Ç–æ–¥—ã
        getStopNotifications,
        getOrderNotifications,
        performBulkNotificationOperation,
        updateNotificationNavigationData
    };
};

export const useBadgeSync = () => {
    const unreadCount = useSelector(state => state.notification?.unreadCount || 0);
    const user = useSelector(selectUser);
    const lastBadgeUpdate = useRef(0);

    useEffect(() => {
        const now = Date.now();
        if (now - lastBadgeUpdate.current < 1000) {
            return;
        }

        if (user?.role === 'CLIENT' && Platform.OS === 'ios') {
            PushNotificationService.setBadgeCount(unreadCount);
            lastBadgeUpdate.current = now;
        }
    }, [unreadCount, user?.role]);
};

export default useNotifications;